\documentclass[12pt,a4paper,oneside]{article} % part, *section, *paragraph
%\documentclass[12pt,a4paper,oneside]{report} % part, *chapter, *section, *paragraph
%\documentclass[12pt,a4paper,oneside]{book} % part, *chapter, *section, *paragraph

%\def\magyarOptions{footnote=starplain} % *, ** típusú lábjegyzet
\usepackage[magyar]{babel}
\ifx\magyarOptions\relax\else 
  \PackageError{magyar.ldf}{http://www.math.bme.hu/latex/}{}        
  \csname @@end\endcsname \fi
\usepackage[latin2]{inputenc}
\usepackage{setspace}
\usepackage[T1]{fontenc} %\showhyphens{integetnem} \showhyphens{meggyültetvény}
%\usepackage{ucs}\usepackage[utf8x]{inputenc}
%\usepackage{fullpage} %\usepackage[margin=2cm]{geometry}
%\usepackage{amsmath,amssymb}
\usepackage{url} %VAGY %\usepackage[unicode]{hyperref}
%\usepackage{listings} % forráskódhoz
%\usepackage{color} 
\usepackage{graphicx}
\usepackage{times}
\usepackage{fullpage}
%\usepackage{showkeys} % \label{} kiírása \ref{}hez
 
\let\stdsection\section
\renewcommand\section{\clearpage\stdsection}
\begin{document}
\onehalfspacing
\begin{center}
\vspace{2em}
%\large{\bf{}BUDAPESTI M\H{U}SZAKI \'ES GAZDAS\'AGTUDOM\'ANYI EGYETEM}
\vspace{.5em}

\includegraphics[width=60mm]{10000000000004C00000014A5D3CE278.eps}

Budapesti Mûszaki és Gazdaságtudományi Egyetem

Méréstechnika és Információs Rendszerek Tanszék
%\vspace{.5em}

%\large{\bf{}VILLAMOSM\'ERN\"OKI \'ES INFORMATIKAI KAR\\
%M\'ERN\"OK INFORMATIKUS SZAK}

\vspace{2em}

%\Large{Informatikai Technol\'ogi\'ak szakir\'any\\
%Rendszerfejleszt\'es \'agazat}

%\vspace{1.5em}

%\Large{\bf{}\"On\'all\'o labor (BMEVIIIA337)}

%\vspace{1.5em}

\LARGE{\bf{}Modellek összehasonlítása és egyesítése}

\vspace{2em}

\begin{tabular}{ l c}
  \parbox{30mm}{\includegraphics[width=20mm]{20090926.eps}} &
  \parbox{120mm}{
\begin{center}
\normalsize{Vajna Miklós (AYU9RZ), I. évf, (MSc) mérnök inf. szakos hallgató

Konzulens: Horváth Ákos, MIT

Szolgáltatásbiztos rendszertervezés szakirány

Önálló laboratórium 1 összefoglaló

2009/10. II. félév}
\end{center}
} \\
\end{tabular}


\end{center}
\thispagestyle{empty}
\newpage

\tableofcontents
\newpage

\section{Bevezetés}

A BME Hibatûrõ rendszerek kutatócsoportjában arra keresem a választ, hogy
lehetséges-e általános megoldást adni modellek összehasonlítására (compare)
és egyesítésére (merge).

A modellek napjainkban kulcsfontosságú szerepet töltenek be a modellvezérelt szoftverfejlesztés folyamatában. A modellvezérelt fejlesztés alapötlete, hogy minél kevesebb programkódot írjunk meg közvetlenül, és minél több esetben egy modellbõl generáljuk azt. Ennek számos elõnye van:

\begin{itemize}
\item Ha a kódgenerátor rendelkezik valamilyen tanusítvánnyal, akkor helyes modell esetén a generált kód is automatikusan megfelel adott elvárásoknak.
\item A modellek magasabb szintû leírást tesznek lehetõvé, mint ha közvetlenül a program forráskódját írnánk.
\item A követhetõséget (traceability) megkönnyíti, láthatjuk, hogy agy adott kódsor a modell mely részének felel meg, majd az mely követelmény teljesítése érdekében szükséges.
\item Forráskód esetében a formális ellenõrzés nehézkes, míg mérnöki modellekbõl jóval egyszerûbb olyan matematikai modelleket elõállítani, melyeken már formális ellenõrzést végezhetünk.
\end{itemize}

A tanszéken fejlesztett VIATRA (VIsual Automated model TRAnsformations) \cite{VIATRA} keretrendszer is ilyen modellekkel dolgozik. A VIATRA modellreprezentációja meglehetõsen egyszerû, a modellek elemei a ModellElementek, és ezeknek két típusa van:

\begin{itemize}
\item Az Entity egy gráf csúcsának feleltethetõ meg.
\item A Relation pedig egy gráf két csúcsát összekötõ élnek.
\end{itemize}

A félév elején azért esett erre a keretrendszerre a választás, mert ha ezen a keretrendszeren sikerül jó modell összehasonlító / egyesítõ algoritmust alkotni, akkor egyrészt azt más keretrendszerre átültetni már nem lehet nagy komplexitású feladat, másrészt a VIATRA rendszerbe számos egyéb metamodellnek megfelelõ modell példányt lehet importálni (számos importer már most is rendelkezésre áll), valamint egy új importer megírása se jelenthet megoldhatatlanul nehéz feladatot.

\section{Feladatok leírása}

A félév során megoldandó feladatokat a következõ részekre lehetett bontani:

\begin{itemize}
\item Megismerkedni a modellek összehasonlításának és egyesítésének nehézségeivel
\item Tanulmányozni a probléma megoldásához használható algoritmusokat
\item Egy konkrét algoritmust portolni / implementálni a VIATRA2 rendszerben
\item Tesztelhetõséget lehetõvé tenni
\end{itemize}

\section{Munkanapló}

\subsection{Elsõ hét}

Az Ericsson egy ipari esettanulmányából \cite{ericsson} kiderül, hogy miért is
annyira égetõ probléma az, hogy sok esetben nincsenek megfelelõ eszközök
modellek összehasonlításához és egyesítéséhez. A cikkben részletezik, hogy az
Ericsson már alkalmazza a modellvezérelt fejlesztés technikáját, és bár
összességében hatékonyabbnak tartja mint modellek nélkül fejleszteni, mégis
nagy nehézséget jelent nekik, ha valamilyen konfliktust kapnak a modellek
verziókezelése során. Ilyenkor egy \emph{merge szobának} keresztelt helységbe
terelik a fejlesztõket, ott nagy képernyõkre kivetítik a modellek egyes
verzióit, melyt megbeszélést tartanak arról, hogy mi is lehetne az egyesített
verzió. Tehát annak ellenére, hogy a technológia növeli a költséghatékonyságot
- állítja az Ericsson -, lenne még mit fejlõdni, azt gondolják, hogy megoldható
lenne, hogy az ilyen modellegyesítési problémák nagyrésze vagy automatizálható
lenne, vagy ha szoftveres támogatást kapnának hozzá a fejlesztõk akkor az ehhez
hasonló konflikusfeloldások jóval egyszerûbbé válnának.

\subsection{Második hét}

A cikk elolvasása után továbbá világossá válik számunkra, hogy:

\begin{itemize}
\item A modellek egyesítésére várhatóan az elkövetkezendõ években egyre nagyobb igény lesz.
\item A forráskódok egyesítéséhez használt algoritmusok nem használhatóak erre a problémára, leszámítva azon kevés eseteket, mikor a modelleket kézzel írjuk le, nem pedig valamilyen grafikus szerkesztõt használva.
\item A probléma azért nehéz, mert az ideális megoldás bármilyen metamodellel rendelkezõ két modellpéldányon mûködne, a jelenleg elérhetõ megoldások pedig csak egyadott metamodellre adnak használható eredményt.
\end{itemize}

A konzultáción arra a következtetésre jutottunk, hogy alapvetõen két megközelítés lehetne sikeres:

\begin{itemize}
\item Figyelni, hogy milyen változtatásokat végeztek a fejlesztõk (pl. refactoring, Foo osztály átnevezése Bar-ra), majd az egyik modellen végrehajtani a másik modellen elvégzett mûveletek sorozatát, így kapva az egyesített eredményt, vagy
\item Csak a kezdeti és végállapotot venni figyelembe pillatkép (snapshot) jelleggel, és arra egy 3-way merge megoldást készíteni.
\end{itemize}

Mindkét megoldásnak megvannak a maga elõnyei és hátrányai.

Az elsõ megoldás elõnye, hogyha például egy adott osztály átnevezése 100 sor kód módosításával jár, a mûvelet tárolása (az eredményezett változtatások tárolása helyett) sokkal kompaktabb változáslistát eredményez. Hátránya, hogy nem feltétlenül felcserélhetõek az egyes mûveletek. Maradva az osztály átnevezési problémánál, ha \emph{A} fejlesztõ még a régi nevével hivatkozik egy hozzáadott kódsorban az osztályra, akkor azt az elõtt kell alkalmazni, hogy \emph{B} azt átnevezte. Ha \emph{A} is nevezett át osztályokat, és \emph{B} is adott hozzás kódsorokat melyek még a régi nevével hivatkoznak az osztályokra, akkor egy olyan triviális megoldás, mely csak egymásután egyszer \emph{A}, aztán \emph{B} (vagy fordítva) mûveleteit alkalmazza nem vezet megoldásra. Ha analógiát keresünk a forráskódokat verziózó rendszerekkel, a Darcs verziókezelõ ilyen algoritmussal rendelkezik. (Ott ezt a problémát úgy oldják meg, hogy az egyes változástípusok mögött precíz matematikai szemantika van, cserébe viszont a gyakorlatban ez nem mindig ad elfogadható gyorsaságú eredményt az algoritmus nagy komplexitása miatt.)

A második megoldásnak a legszembetûnõbb elõnye, hogy nem érzékeny a változtatások számára, hiszen csak az elsõ és a végsõ állapotot veszi figyelembe. Természetesen cserébe ilyenkor gondjaink lehetnek abban az esetben ha a refactoring mértéke nem elhanyagolható az egyéb változtatásokhoz viszonyítva.

Összességében tehát megállapíthatjuk, hogy minkét technika lehet sikeres, nem érdemes egyiket se elvetni.

\subsection{Harmadik hét}

Zager és Verghese \cite{zager} cikkébõl kiderül, hogy a modellek összehasonlításának problémája megfeleltethetõ gráfok összehasonlításának \footnote{Feltéve, hogyha a pillanatkép-jellegû hozzáállást követjük.}. Ehhez a matematikának széles fegyvertára van, ugyanakkor heurisztikák nélkül a probléma túl nehéz ahhoz, hogy a gyakorlatban elfogadható idejû eredményt kapjunk. Egy heurisztika lehet egy iteratív algoritmus, melyben egy $ G_a $ és $ G_b $ gráfban lévõ pont akkor hasonló, ha a szomszédaik hasonlóak, az élek pedig akkor ha a forrás/cél pontok hasonlóak.

A cikk részetesen foglalkozik azzal, hogy hogyan tudjuk megtalálni, hogy két gráfban hol vannak hasonló részek (similarity). A részgráfok esetén tervezési döntés, hogy a részben hasonlókkal vagy csak az izomorfakkal akarunk foglalkozni a párosítás kialakítása során (matching).

Ohst, Welle és Kelter \cite{umlsimilarity} cikke konkrétan UML modellekkel foglalkozik. Kiemeli annak fontosságát, hogy ha két modellt összehasonlítunk, akkor az érdektelen adatokat figyelmen kívül kell hagyni, például az egyes modell elemek pozícióját (layout info). Foglalkozik a vizuális megjelenés prolémájával, erre mutat pozitív és negatív példát is. Kiemeli, hogy lényeges különbség lehet modellek között, hogy van-e az elemeknek egyedi azonosítójuk (UUID), ennek hiányában a probléma perfekt megoldása sajnálatos módon NP-teljes. Hivatkozik a Rational Rose termékre, melyben egyfelõl van modell összehasonlítási / egyesítési funkcionalitás, másrészt viszont az egyesítés során elõkerül a modell konkrét XML-alapú szintaxisa, ennek ismerete nélkül aligha tudunk sikeres egyesítéseket véghezvinni.

Az idáigi cikkekbõl a következõ szempontok derültek ki az összehasonlító algoritmusokat illetõen:

\begin{itemize}
\item Történettel (history) foglalkozó / nem foglalkozó algoritmus
\item Egyedi azonosítást lehetõvé tevõ elem létezése / nem létezése
\item Az algoritmus metamodell-specifikus-e
\item A fejlesztõ grafikus felületet kap-e vagy a konkrét szintaxist is ismernie kell
\end{itemize}

\subsection{Negyedik hét}

Gráfok hasonlóságának alapkérdéseivel foglalkozik Zager és Verghese prezentációja \cite{graphsimilarity}, melyben a hasonlóság következõ fajtáit határozzák meg:

\begin{itemize}
\item Izomorfia (csak igen/nem a válasz)
\item Szerkeszétsi távolság: hány lépés kell ahhoz, hogy az egyik gráfból eljussunk a másikba.
\item Maximális / minimális mérete a részgráfoknak / szupergráfnak
\end{itemize}

Zager MSc dolgozata \cite{zagermsc} a következõ újdonságokkal szolgál:

\begin{itemize}
\item Úgy is neki lehet állni a problémának, hogy a gráfokat különféle módokon mátrixokként ábrázoljuk és ezeket hasonlítjuk össze.
\item A feljebb említett iteratív hasonlóság-keresõ módszerét itt részletesen kifejti.
\end{itemize}

Lin, Gray és Jouault cikke \cite{dsmdiff} azt hangsúlyozza, hogy fontos, hogy az algoritmus metamodelltõl független legyen, a cikkben ismertetett \emph{DSMDiff} tetszóleges domain-specifikus nyelven íródott modellpélányokat kíván összehasonlítani. Magáról a DSMDiff-rõl nagyon keveset sikerült kideríteni, pedig a cikk szerint ez nem csak egy terv, hanem implementálták is.

Lin, Zhang és Gray cikke \cite{comparechal} problémafelvetési céllal íródott, nem tartalmaz konkrét megoldásokat. A 2004-es írásban felvetett problémák egy rész már megoldódott, mivel részben a CVS problémái voltak ezek, melyek közül számosat az SVN már ma is megold, például a projekt-szintû verziózást a fájl-szintû helyett.

Ezen a héten ezen kívül a cikkek keresése mellett az is napirendre került, hogy mely már létezõ projekteket lenne érdemes kipróbálni ebben a témakörben.

A két elsõ jelölt:

\begin{itemize}
\item EMF Compare \cite{emfcompare}
\item Groove \cite{groove}
\end{itemize}

Levelezés alapján a probléma sokadik megfogalmazása: az egyesítõ algoritmus jó lenne, ha nem egyetlen metamodell fölött tudna mûködni, cserébe viszont ha semmit se tudunk a metamodellrõl akkor nemnagyon lehet jól egyesíteni. Erre megoldás lehet, ha a metamodell információi is az algoritmus inputját képezik a két modellpélány mellett. Egy másik megoldás lehet, ha a metamodell információi alapján tudunk kódot generálni, és így tetszõleges metamodell számára könnyen elékészíthetõ a mûködõ algoritmus-implementáció.

Ezen kívül még probléma, hogy az algoritmusnak nagy elemszámú modelleket is jól kell tudnia kezelnie, a jelenlegi megoldások nagyrésze párezer elem felett már nem végez gyakorlatben megengedhetõ idõn belül.

\subsection{Ötödik hét}

A héten olyan gráfok összehasonlítását végzõ algoritmusokat kerestem, melyek fák (körmentes gráfok). A szakoridalom ilyen téren már kevésbe gazdag, pedig számos metamodell-csoport (például az összes EMF által kezelt) szigorú tartalmazási hierarchia szerint épül fel, tehát faként reprezentálható.

Az egyik legérdekesebb Wang, DeWitt és Cai cikke \cite{xdiff}, melyben az
\emph{X-Diff} algoritmust vázolják. Az algoritmust alapötlete nagyon hasonlít a
késõbb tárgyalt \emph{FMES} algoritmushoz, viszont ehhez nem találtam
nyilvánosan elérhetõ mûködõ kódot.

\subsection{Hatodik hét}

A következõ lépés a VIATRA2 rendszerrel való ismerkedés volt. Mivel egy hallgató már korábban foglalkozott modell összehasonlítási témával, így elõször az ö algoritmusát \cite{karer} próbáltam ki. Ez a keretrendszerrel való ismerkedéshez kíváló feladat volt, az algoritmus viszont az én inputomra lefagyott (\emph{NullPointerException}).

Ezzel párhuzamosan megpróbáltam felvenni a kapcsolatot az \emph{Odyssey-VCS}\cite{odyssey} szerzõivel, melynek célja egy modellek kezelésére kitalált EMF-alapó verziókezelõ lenne. Sajnálatos módon a szoftver elsó blikkre (out of the box) nem mûködött, a forráskódot meg többszöri levélváltás után se sikerült végül megkapni, bár határozott elutasítást nem kaptam (kutatási célokra).

\section{Jövõbeli lehetõségek}

\begin{thebibliography}{4}
\addcontentsline{toc}{section}{Hivatkozások}

%\bibitem{Programming Erlang} Joe Armstrong: Programming Erlang, http://www.p.com/jaerlang/programming
\bibitem{VIATRA} VIATRA2 (VIsual Automated model TRAnsformations), http://wiki.eclipse.org/VIATRA2
\bibitem{ericsson} Lars Bendix, Pär Emanuelsson: Requirements for Practical Model Merge - An Industrial Perspective
\bibitem{zager} LA Zager, GC Verghese: Graph similarity scoring and matching
\bibitem{umlsimilarity} D Ohst, M Welle, U Kelter: Differences between versions of UML diagrams
\bibitem{graphsimilarity} Laura Zager, George Verghese: Graph similarity
\bibitem{zagermsc} Laura Zager: Graph Similarity and Matching
\bibitem{dsmdiff} Y Lin, J Gray, F Jouault: DSMDiff - a differentiation tool for domain-specific models
\bibitem{comparechal} Y Lin, J Zhang, J Gray: Model Comparison - A Key Challenge for Transformation Testing and Version Control in Model Driven Software Development
\bibitem{emfcompare} Eclipse Modeling Framework Compare, http://wiki.eclipse.org/index.php/EMF\_Compare
\bibitem{groove} GRaphs for Object-Oriented VErification, http://sourceforge.net/projects/groove/
\bibitem{xdiff} Yuan Wang, David J. DeWitt, Jin-Yi Cai: X-Diff - An Effective Change Detection Algorithm for XML Documents
\bibitem{karer} VIATRA2 Model Comparator by Name, https://svn.inf.mit.bme.hu/ viatra/viatra\_extra/ R3/mit.bme.hu/ trunk/org.eclipse.viatra2.model.comparator/ src/org/ eclipse/viatra2/ model/comparator/ algorithms/karer/
\bibitem{odyssey} Hamilton Oliveira, Leonardo Murta, Cláudia Werner: Odyssey-VCS - a Flexible Version Control System for UML Model Elements

\end{thebibliography}
\end{document}
