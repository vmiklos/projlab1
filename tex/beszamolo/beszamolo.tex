\documentclass[12pt,a4paper,oneside]{article} % part, *section, *paragraph
%\documentclass[12pt,a4paper,oneside]{report} % part, *chapter, *section, *paragraph
%\documentclass[12pt,a4paper,oneside]{book} % part, *chapter, *section, *paragraph

%\def\magyarOptions{footnote=starplain} % *, ** típusú lábjegyzet
\usepackage[magyar]{babel}
\ifx\magyarOptions\relax\else 
  \PackageError{magyar.ldf}{http://www.math.bme.hu/latex/}{}        
  \csname @@end\endcsname \fi
\usepackage[latin2]{inputenc}
\usepackage{setspace}
\usepackage[T1]{fontenc} %\showhyphens{integetnem} \showhyphens{meggyültetvény}
%\usepackage{ucs}\usepackage[utf8x]{inputenc}
%\usepackage{fullpage} %\usepackage[margin=2cm]{geometry}
%\usepackage{amsmath,amssymb}
\usepackage{url} %VAGY %\usepackage[unicode]{hyperref}
%\usepackage{listings} % forráskódhoz
%\usepackage{color} 
\usepackage{graphicx}
\usepackage{times}
\usepackage{fullpage}
%\usepackage{showkeys} % \label{} kiírása \ref{}hez
 
\let\stdsection\section
\renewcommand\section{\clearpage\stdsection}
\begin{document}
\onehalfspacing
\begin{center}
\vspace{2em}
%\large{\bf{}BUDAPESTI M\H{U}SZAKI \'ES GAZDAS\'AGTUDOM\'ANYI EGYETEM}
\vspace{.5em}

\includegraphics[width=60mm]{10000000000004C00000014A5D3CE278.eps}

Budapesti Mûszaki és Gazdaságtudományi Egyetem

Méréstechnika és Információs Rendszerek Tanszék
%\vspace{.5em}

%\large{\bf{}VILLAMOSM\'ERN\"OKI \'ES INFORMATIKAI KAR\\
%M\'ERN\"OK INFORMATIKUS SZAK}

\vspace{2em}

%\Large{Informatikai Technol\'ogi\'ak szakir\'any\\
%Rendszerfejleszt\'es \'agazat}

%\vspace{1.5em}

%\Large{\bf{}\"On\'all\'o labor (BMEVIIIA337)}

%\vspace{1.5em}

\LARGE{\bf{}Modellek összehasonlítása és egyesítése}

\vspace{2em}

\begin{tabular}{ l c}
  \parbox{30mm}{\includegraphics[width=20mm]{20090926.eps}} &
  \parbox{120mm}{
\begin{center}
\normalsize{Vajna Miklós (AYU9RZ), I. évf, (MSc) mérnök inf. szakos hallgató

Konzulens: Horváth Ákos, MIT

Szolgáltatásbiztos rendszertervezés szakirány

Önálló laboratórium 1 összefoglaló

2009/10. II. félév}
\end{center}
} \\
\end{tabular}


\end{center}
\thispagestyle{empty}
\newpage

\tableofcontents
\newpage

\section{Bevezetés}

A BME Hibatûrõ rendszerek kutatócsoportjában arra keresem a választ, hogy
lehetséges-e általános megoldást adni modellek összehasonlítására (compare)
és egyesítésére (merge).

A modellek napjainkban kulcsfontosságú szerepet töltenek be a modellvezérelt szoftverfejlesztés folyamatában. A modellvezérelt fejlesztés alapötlete, hogy minél kevesebb programkódot írjunk meg közvetlenül, és minél több esetben egy modellbõl generáljuk azt. Ennek számos elõnye van:

\begin{itemize}
\item Ha a kódgenerátor rendelkezik valamilyen tanusítvánnyal, akkor helyes modell esetén a generált kód is automatikusan megfelel adott elvárásoknak.
\item A modellek magasabb szintû leírást tesznek lehetõvé, mint ha közvetlenül a program forráskódját írnánk.
\item A követhetõséget (traceability) megkönnyíti, láthatjuk, hogy agy adott kódsor a modell mely részének felel meg, majd az mely követelmény teljesítése érdekében szükséges.
\item Forráskód esetében a formális ellenõrzés nehézkes, míg mérnöki modellekbõl jóval egyszerûbb olyan matematikai modelleket elõállítani, melyeken már formális ellenõrzést végezhetünk.
\end{itemize}

A tanszéken fejlesztett VIATRA (VIsual Automated model TRAnsformations) \cite{VIATRA} keretrendszer is ilyen modellekkel dolgozik. A VIATRA modellreprezentációja meglehetõsen egyszerû, a modellek elemei a ModellElementek, és ezeknek két típusa van:

\begin{itemize}
\item Az Entity egy gráf csúcsának feleltethetõ meg.
\item A Relation pedig egy gráf két csúcsát összekötõ élnek.
\end{itemize}

A félév elején azért esett erre a keretrendszerre a választás, mert ha ezen a keretrendszeren sikerül jó modell összehasonlító / egyesítõ algoritmust alkotni, akkor egyrészt azt más keretrendszerre átültetni már nem lehet nagy komplexitású feladat, másrészt a VIATRA rendszerbe számos egyéb metamodellnek megfelelõ modell példányt lehet importálni (számos importer már most is rendelkezésre áll), valamint egy új importer megírása se jelenthet megoldhatatlanul nehéz feladatot.

\section{Feladatok leírása}

A félév során megoldandó feladatokat a következõ részekre lehetett bontani:

\begin{itemize}
\item Megismerkedni a modellek összehasonlításának és egyesítésének nehézségeivel
\item Tanulmányozni a probléma megoldásához használható algoritmusokat
\item Egy konkrét algoritmust portolni / implementálni a VIATRA2 rendszerben
\item Tesztelhetõséget lehetõvé tenni
\end{itemize}

\section{Munkanapló}

\subsection{Elsõ hét}

Az Ericsson egy ipari esettanulmányából \cite{ericsson} kiderül, hogy miért is
annyira égetõ probléma az, hogy sok esetben nincsenek megfelelõ eszközök
modellek összehasonlításához és egyesítéséhez. A cikkben részletezik, hogy az
Ericsson már alkalmazza a modellvezérelt fejlesztés technikáját, és bár
összességében hatékonyabbnak tartja mint modellek nélkül fejleszteni, mégis
nagy nehézséget jelent nekik, ha valamilyen konfliktust kapnak a modellek
verziókezelése során. Ilyenkor egy \emph{merge szobának} keresztelt helységbe
terelik a fejlesztõket, ott nagy képernyõkre kivetítik a modellek egyes
verzióit, melyt megbeszélést tartanak arról, hogy mi is lehetne az egyesített
verzió. Tehát annak ellenére, hogy a technológia növeli a költséghatékonyságot
- állítja az Ericsson -, lenne még mit fejlõdni, azt gondolják, hogy megoldható
lenne, hogy az ilyen modellegyesítési problémák nagyrésze vagy automatizálható
lenne, vagy ha szoftveres támogatást kapnának hozzá a fejlesztõk akkor az ehhez
hasonló konflikusfeloldások jóval egyszerûbbé válnának.

\subsection{Második hét}

A cikk elolvasása után továbbá világossá válik számunkra, hogy:

\begin{itemize}
\item A modellek egyesítésére várhatóan az elkövetkezendõ években egyre nagyobb igény lesz.
\item A forráskódok egyesítéséhez használt algoritmusok nem használhatóak erre a problémára, leszámítva azon kevés eseteket, mikor a modelleket kézzel írjuk le, nem pedig valamilyen grafikus szerkesztõt használva.
\item A probléma azért nehéz, mert az ideális megoldás bármilyen metamodellel rendelkezõ két modellpéldányon mûködne, a jelenleg elérhetõ megoldások pedig csak egyadott metamodellre adnak használható eredményt.
\end{itemize}

A konzultáción arra a következtetésre jutottunk, hogy alapvetõen két megközelítés lehetne sikeres:

\begin{itemize}
\item Figyelni, hogy milyen változtatásokat végeztek a fejlesztõk (pl. refactoring, Foo osztály átnevezése Bar-ra), majd az egyik modellen végrehajtani a másik modellen elvégzett mûveletek sorozatát, így kapva az egyesített eredményt, vagy
\item Csak a kezdeti és végállapotot venni figyelembe pillatkép (snapshot) jelleggel, és arra egy 3-way merge megoldást készíteni.
\end{itemize}

Mindkét megoldásnak megvannak a maga elõnyei és hátrányai.

Az elsõ megoldás elõnye, hogyha például egy adott osztály átnevezése 100 sor kód módosításával jár, a mûvelet tárolása (az eredményezett változtatások tárolása helyett) sokkal kompaktabb változáslistát eredményez. Hátránya, hogy nem feltétlenül felcserélhetõek az egyes mûveletek. Maradva az osztály átnevezési problémánál, ha \emph{A} fejlesztõ még a régi nevével hivatkozik egy hozzáadott kódsorban az osztályra, akkor azt az elõtt kell alkalmazni, hogy \emph{B} azt átnevezte. Ha \emph{A} is nevezett át osztályokat, és \emph{B} is adott hozzás kódsorokat melyek még a régi nevével hivatkoznak az osztályokra, akkor egy olyan triviális megoldás, mely csak egymásután egyszer \emph{A}, aztán \emph{B} (vagy fordítva) mûveleteit alkalmazza nem vezet megoldásra. Ha analógiát keresünk a forráskódokat verziózó rendszerekkel, a Darcs verziókezelõ ilyen algoritmussal rendelkezik. (Ott ezt a problémát úgy oldják meg, hogy az egyes változástípusok mögött precíz matematikai szemantika van, cserébe viszont a gyakorlatban ez nem mindig ad elfogadható gyorsaságú eredményt az algoritmus nagy komplexitása miatt.)

A második megoldásnak a legszembetûnõbb elõnye, hogy nem érzékeny a változtatások számára, hiszen csak az elsõ és a végsõ állapotot veszi figyelembe. Természetesen cserébe ilyenkor gondjaink lehetnek abban az esetben ha a refactoring mértéke nem elhanyagolható az egyéb változtatásokhoz viszonyítva.

Összességében tehát megállapíthatjuk, hogy minkét technika lehet sikeres, nem érdemes egyiket se elvetni.

\subsection{Harmadik hét}

Zager és Verghese \cite{zager} cikkébõl kiderül, hogy a modellek összehasonlításának problémája megfeleltethetõ gráfok összehasonlításának \footnote{Feltéve, hogyha a pillanatkép-jellegû hozzáállást követjük.}. Ehhez a matematikának széles fegyvertára van, ugyanakkor heurisztikák nélkül a probléma túl nehéz ahhoz, hogy a gyakorlatban elfogadható idejû eredményt kapjunk. Egy heurisztika lehet egy iteratív algoritmus, melyben egy $ G_a $ és $ G_b $ gráfban lévõ pont akkor hasonló, ha a szomszédaik hasonlóak, az élek pedig akkor ha a forrás/cél pontok hasonlóak.

A cikk részetesen foglalkozik azzal, hogy hogyan tudjuk megtalálni, hogy két gráfban hol vannak hasonló részek (similarity). A részgráfok esetén tervezési döntés, hogy a részben hasonlókkal vagy csak az izomorfakkal akarunk foglalkozni a párosítás kialakítása során (matching).

Ohst, Welle és Kelter \cite{umlsimilarity} cikke konkrétan UML modellekkel foglalkozik. Kiemeli annak fontosságát, hogy ha két modellt összehasonlítunk, akkor az érdektelen adatokat figyelmen kívül kell hagyni, például az egyes modell elemek pozícióját (layout info). Foglalkozik a vizuális megjelenés prolémájával, erre mutat pozitív és negatív példát is. Kiemeli, hogy lényeges különbség lehet modellek között, hogy van-e az elemeknek egyedi azonosítójuk (UUID), ennek hiányában a probléma perfekt megoldása sajnálatos módon NP-teljes. Hivatkozik a Rational Rose termékre, melyben egyfelõl van modell összehasonlítási / egyesítési funkcionalitás, másrészt viszont az egyesítés során elõkerül a modell konkrét XML-alapú szintaxisa, ennek ismerete nélkül aligha tudunk sikeres egyesítéseket véghezvinni.

Az idáigi cikkekbõl a következõ szempontok derültek ki az összehasonlító algoritmusokat illetõen:

\begin{itemize}
\item Történettel (history) foglalkozó / nem foglalkozó algoritmus
\item Egyedi azonosítást lehetõvé tevõ elem létezése / nem létezése
\item Az algoritmus metamodell-specifikus-e
\item A fejlesztõ grafikus felületet kap-e vagy a konkrét szintaxist is ismernie kell
\end{itemize}

\subsection{Negyedik hét}



\section{Jövõbeli lehetõségek}

\begin{thebibliography}{4}
\addcontentsline{toc}{section}{Hivatkozások}

%\bibitem{Programming Erlang} Joe Armstrong: Programming Erlang, http://www.p.com/jaerlang/programming
\bibitem{VIATRA} VIATRA2 (VIsual Automated model TRAnsformations), http://wiki.eclipse.org/VIATRA2
\bibitem{ericsson} Lars Bendix, Pär Emanuelsson: Requirements for Practical Model Merge - An Industrial Perspective
\bibitem{zager} LA Zager, GC Verghese: Graph similarity scoring and matching
\bibitem{umlsimilarity} D Ohst, M Welle, U Kelter: Differences between versions of UML diagrams

\end{thebibliography}
\end{document}
