\documentclass[12pt,a4paper,oneside]{article} % part, *section, *paragraph
%\documentclass[12pt,a4paper,oneside]{report} % part, *chapter, *section, *paragraph
%\documentclass[12pt,a4paper,oneside]{book} % part, *chapter, *section, *paragraph

%\def\magyarOptions{footnote=starplain} % *, ** típusú lábjegyzet
\usepackage[magyar]{babel}
\ifx\magyarOptions\relax\else 
  \PackageError{magyar.ldf}{http://www.math.bme.hu/latex/}{}        
  \csname @@end\endcsname \fi
\usepackage[latin2]{inputenc}
\usepackage{setspace}
\usepackage{float}
\usepackage[T1]{fontenc} %\showhyphens{integetnem} \showhyphens{meggyültetvény}
%\usepackage{ucs}\usepackage[utf8x]{inputenc}
%\usepackage{fullpage} %\usepackage[margin=2cm]{geometry}
%\usepackage{amsmath,amssymb}
\usepackage{url} %VAGY %\usepackage[unicode]{hyperref}
%\usepackage{listings} % forráskódhoz
%\usepackage{color} 
\usepackage{graphicx}
\usepackage{times}
\usepackage{fullpage}
%\usepackage{showkeys} % \label{} kiírása \ref{}hez
 
\let\stdsection\section
\renewcommand\section{\clearpage\stdsection}
\begin{document}
\onehalfspacing
\begin{center}
\vspace{2em}
%\large{\bf{}BUDAPESTI M\H{U}SZAKI \'ES GAZDAS\'AGTUDOM\'ANYI EGYETEM}
\vspace{.5em}

\includegraphics[width=60mm]{10000000000004C00000014A5D3CE278.eps}

Budapesti Mûszaki és Gazdaságtudományi Egyetem

Méréstechnika és Információs Rendszerek Tanszék
%\vspace{.5em}

%\large{\bf{}VILLAMOSM\'ERN\"OKI \'ES INFORMATIKAI KAR\\
%M\'ERN\"OK INFORMATIKUS SZAK}

\vspace{2em}

%\Large{Informatikai Technol\'ogi\'ak szakir\'any\\
%Rendszerfejleszt\'es \'agazat}

%\vspace{1.5em}

%\Large{\bf{}\"On\'all\'o labor (BMEVIIIA337)}

%\vspace{1.5em}

\LARGE{\bf{}Modellek összehasonlítása és egyesítése}

\vspace{2em}

\begin{tabular}{ l c}
  \parbox{30mm}{\includegraphics[width=20mm]{20090926.eps}} &
  \parbox{120mm}{
\begin{center}
\normalsize{Vajna Miklós (AYU9RZ), I. évf, (MSc) mérnök inf. szakos hallgató

Konzulens: Horváth Ákos, MIT

Szolgáltatásbiztos rendszertervezés szakirány

Önálló laboratórium 1 összefoglaló

2009/10. II. félév}
\end{center}
} \\
\end{tabular}


\end{center}
\thispagestyle{empty}
\newpage

\tableofcontents
\newpage

\section{Bevezetés}

A BME Hibatûrõ rendszerek kutatócsoportjában arra keresem a választ, hogy
lehetséges-e általános megoldást adni modellek összehasonlítására (compare)
és egyesítésére (merge).

A modellek napjainkban kulcsfontosságú szerepet töltenek be a modellvezérelt szoftverfejlesztés folyamatában. A modellvezérelt fejlesztés alapötlete, hogy minél kevesebb programkódot írjunk meg közvetlenül, és minél több esetben egy modellbõl generáljuk azt. Ennek számos elõnye van:

\begin{itemize}
\item Ha a kódgenerátor rendelkezik valamilyen tanusítvánnyal, akkor helyes modell esetén a generált kód is automatikusan megfelel adott elvárásoknak.
\item A modellek magasabb szintû leírást tesznek lehetõvé, mint ha közvetlenül a program forráskódját írnánk.
\item A követhetõséget (traceability) megkönnyíti, láthatjuk, hogy agy adott kódsor a modell mely részének felel meg, majd az mely követelmény teljesítése érdekében szükséges.
\item Forráskód esetében a formális ellenõrzés nehézkes, míg mérnöki modellekbõl jóval egyszerûbb olyan matematikai modelleket elõállítani, melyeken már formális ellenõrzést végezhetünk.
\end{itemize}

A tanszéken fejlesztett VIATRA (VIsual Automated model TRAnsformations) \cite{VIATRA} keretrendszer is ilyen modellekkel dolgozik. A VIATRA modellreprezentációja meglehetõsen egyszerû, a modellek elemei a ModellElementek, és ezeknek két típusa van:

\begin{itemize}
\item Az Entity egy gráf csúcsának feleltethetõ meg.
\item A Relation pedig egy gráf két csúcsát összekötõ élnek.
\end{itemize}

A félév elején azért esett erre a keretrendszerre a választás, mert ha ezen a keretrendszeren sikerül jó modell összehasonlító / egyesítõ algoritmust alkotni, akkor egyrészt azt más keretrendszerre átültetni már nem lehet nagy komplexitású feladat, másrészt a VIATRA rendszerbe számos egyéb metamodellnek megfelelõ modell példányt lehet importálni (számos importer már most is rendelkezésre áll), valamint egy új importer megírása se jelenthet megoldhatatlanul nehéz feladatot.

A félév során megoldandó feladatokat a következõ részekre lehetett bontani:

\begin{itemize}
\item Megismerkedni a modellek összehasonlításának és egyesítésének nehézségeivel
\item Tanulmányozni a probléma megoldásához használható algoritmusokat
\item Egy konkrét algoritmust portolni / implementálni a VIATRA2 rendszerben
\item Tesztelhetõséget lehetõvé tenni
\end{itemize}

\section{Háttérismeret}

Tekintve, hogy a modellvezérelt szoftverfejlesztés témakörében nem voltam
jártas a félév során, kézenfekvõnek tûnt, hogy mielõtt nekiállnék egy saját
megoldás elkészítésének, elõször az ide vonatkozó szakirodalmat áttekintsem.
Rövidesen kiderült, hogy modellek összehasonlításával, vagy ennél
általánosabban gráfok izomorfiájának vizsgálatával már nagyon sokan
foglalkoztak, ezekbõl igyekeztem a gyakrabban elõforduló problémákkal
megismerkedni, illetve az ezekre adható megoldásokat megismerni.

A félév során olvasott cikkek, illetve kipróbált szoftverek részletes leírása
elõtt hasonlítsuk össze elõször röviden a cikkeket:

\begin{center}
\begin{table}[H]
\begin{tabular}{| l | l | p{10cm} |}
\hline
Cikk & Típus & Rövid leírás \\ \hline
\cite{ericsson} & probléma leírás & Rávilágít arra, hogy a modellek összehasonlítása mennyivel bonyolultabb, mint a forráskódoké. \\
\cite{zager} & konkrét eredmény & Egy megoldást ad arra, hogy gráfok hasonlóságát hogyan lehet mérni. \\
\cite{umlsimilarity} & probléma leírás & Szûkítve a témakört, UML modellek összehasonlításának nehézségeit részletezi. \\
\cite{graphsimilarity} & prezentáció & Nem tartalmaz probléma-leírást vagy megoldást, lehetséges megoldások típusait vázolja. \\
\cite{zagermsc} & konkrét eredmény & Lényegében a \cite{zager} cikk késõbbi verziója, jelentõsen bõvítve és továbbgondolva. \\
\cite{dsmdiff} & probléma leírás & Felveti, hogy fontos, hogy egy összehasonlító algoritmus bármilyen metamodell fölött mûködni tudjon. \\
\cite{comparechal} & probléma leírás & Modellek összehasonlítását a verziókezelõk oldaláról közelíti meg. \\
\cite{xdiff} & konkrét eredmény & A késõbb tárgyalt FMES algoritmushoz hasonló megoldást ismertet. \\
\cite{odyssey} & konkrét eredmény & Egy modellek kezelésére kifejlesztett verziókezelõ. \\
\cite{changedriven} & konkrét eredmény & A változás-vezérelt összehasonlításra egy lehetséges megoldás. \\
\hline
\end{tabular}
\caption{A félév során olvasott cikkek összehasonlítása}
\end{table}
\end{center}

\clearpage
Valamint ez egyes szoftvereket:

\begin{center}
\begin{table}[H]
\begin{tabular}{| l | l | p{10cm} |}
\hline
Szoftver & Állapot & Rövid leírás \\ \hline
\cite{VIATRA} & Aktívan fejlesztett & Konkrét mûködõ modell-összehasonlító algoritmust nem tartalmaz, de van rá lehetõség \\
\cite{emfcompare} & Aktívan fejelsztett & Mûködõ algoritmust tartalmaz, de csak EMF metamodellel mûködik \\
\cite{groove} & Aktívan fejlesztett & Objektum-orientált verifikálás céljából kezel gráfokat, gráf-összehasonlító megoldást tartalmaz. \\
\cite{diffxml} & Karbantartott & 2002-ben fejlesztett eszköz, mely séma nélküli XML fájlokat hasonlít össze és egyesít. \\
\hline
\end{tabular}
\caption{A félév során kipróbált szoftverek összehasonlítása}
\end{table}
\end{center}

A fejezet további részében tehát ezeknek a munkáknak a részletes ismertetése
következik, két részre csoportosítva: az egyes cikkek részletezését követõen az
utolsó négy alfejezet konkrét szoftverekkel foglalkozik.

\subsection{Ericsson}

Az Ericsson egy ipari esettanulmányából \cite{ericsson} kiderül, hogy miért is
annyira égetõ probléma az, hogy sok esetben nincsenek megfelelõ eszközök
modellek összehasonlításához és egyesítéséhez. A cikkben részletezik, hogy az
Ericsson már alkalmazza a modellvezérelt fejlesztés technikáját, és bár
összességében hatékonyabbnak tartja mint modellek nélkül fejleszteni, mégis
nagy nehézséget jelent nekik, ha valamilyen konfliktust kapnak a modellek
verziókezelése során. Ilyenkor egy \emph{merge szobának} keresztelt helységbe
terelik a fejlesztõket, ott nagy képernyõkre kivetítik a modellek egyes
verzióit, melyt megbeszélést tartanak arról, hogy mi is lehetne az egyesített
verzió. Tehát annak ellenére, hogy a technológia növeli a költséghatékonyságot
- állítja az Ericsson -, lenne még mit fejlõdni, azt gondolják, hogy megoldható
lenne, hogy az ilyen modellegyesítési problémák nagyrésze vagy automatizálható
lenne, vagy ha szoftveres támogatást kapnának hozzá a fejlesztõk akkor az ehhez
hasonló konflikusfeloldások jóval egyszerûbbé válnának.

A cikk elolvasása után továbbá világossá válik számunkra, hogy:

\begin{itemize}
\item A modellek egyesítésére várhatóan az elkövetkezendõ években egyre nagyobb igény lesz.
\item A forráskódok egyesítéséhez használt algoritmusok nem használhatóak erre a problémára, leszámítva azon kevés eseteket, mikor a modelleket kézzel írjuk le, nem pedig valamilyen grafikus szerkesztõt használva.
\item A probléma azért nehéz, mert az ideális megoldás bármilyen metamodellel rendelkezõ két modellpéldányon mûködne, a jelenleg elérhetõ megoldások pedig csak egyadott metamodellre adnak használható eredményt.
\end{itemize}

A konzultáción arra a következtetésre jutottunk, hogy alapvetõen két megközelítés lehetne sikeres:

\begin{itemize}
\item Figyelni, hogy milyen változtatásokat végeztek a fejlesztõk (pl. refactoring, Foo osztály átnevezése Bar-ra), majd az egyik modellen végrehajtani a másik modellen elvégzett mûveletek sorozatát, így kapva az egyesített eredményt, vagy
\item Csak a kezdeti és végállapotot venni figyelembe pillanatkép (snapshot) jelleggel, és arra egy 3-way merge megoldást készíteni.
\end{itemize}

Mindkét megoldásnak megvannak a maga elõnyei és hátrányai.

Az elsõ megoldás elõnye, hogyha például egy adott osztály átnevezése 100 sor kód módosításával jár, a mûvelet tárolása (az eredményezett változtatások tárolása helyett) sokkal kompaktabb változáslistát eredményez. Hátránya, hogy nem feltétlenül felcserélhetõek az egyes mûveletek. Maradva az osztály átnevezési problémánál, ha \emph{A} fejlesztõ még a régi nevével hivatkozik egy hozzáadott kódsorban az osztályra, akkor azt az elõtt kell alkalmazni, hogy \emph{B} azt átnevezte. Ha \emph{A} is nevezett át osztályokat, és \emph{B} is adott hozzá kódsorokat melyek még a régi nevével hivatkoznak az osztályokra, akkor egy olyan triviális megoldás, mely csak egymásután egyszer \emph{A}, aztán \emph{B} (vagy fordítva) mûveleteit alkalmazza nem vezet megoldásra. Ha analógiát keresünk a forráskódokat verziózó rendszerekkel, a Darcs verziókezelõ ilyen algoritmussal rendelkezik. (Ott ezt a problémát úgy oldják meg, hogy az egyes változástípusok mögött precíz matematikai szemantika van, cserébe viszont a gyakorlatban ez nem mindig ad elfogadható gyorsaságú eredményt az algoritmus nagy komplexitása miatt.)

A második megoldásnak a legszembetûnõbb elõnye, hogy nem érzékeny a változtatások számára, hiszen csak az elsõ és a végsõ állapotot veszi figyelembe. Továbbá ez az egyetlen lehetõségünk ha gyorsan szeretnénk az összehasonlítást elvégezni és a modell szerkesztõ nem támogatja az operációk rögzítését. Természetesen cserébe ilyenkor gondjaink lehetnek abban az esetben ha a refactoring mértéke nem elhanyagolható az egyéb változtatásokhoz viszonyítva. (Forráskód kezelésénél a Git rendszer alapértelmezett egyesítõ algoritmusa ilyen: olyankor is adhat konfliktust mikor az operációk rögzítésével az egyesítés automatizálható lenne, viszont az egyesítõ algoritmus gyorsaságával szemmel láthatólag nincsenek gondok.)

Összességében tehát megállapíthatjuk, hogy minkét technika lehet sikeres, nem érdemes egyiket se elvetni.

\subsection{Gráfok hasonlóságának mérése}

Zager és Verghese \cite{zager} cikkébõl kiderül, hogy a modellek összehasonlításának problémája megfeleltethetõ gráfok összehasonlításának \footnote{Feltéve, hogyha a pillanatkép-jellegû hozzáállást követjük.}. Ehhez a matematikának széles fegyvertára van, ugyanakkor heurisztikák nélkül a probléma túl nehéz ahhoz, hogy a gyakorlatban elfogadható idejû eredményt kapjunk. Egy heurisztika lehet egy iteratív algoritmus, melyben egy $ G_a $ és $ G_b $ gráfban lévõ pont akkor hasonló, ha a szomszédaik hasonlóak, az élek pedig akkor ha a forrás/cél pontok hasonlóak.

A cikk részletesen foglalkozik azzal, hogy hogyan tudjuk megtalálni, hogy két gráfban hol vannak hasonló részek (similarity). A részgráfok esetén tervezési döntés, hogy a részben hasonlókkal vagy csak az izomorfakkal akarunk foglalkozni a párosítás kialakítása során (matching).

\subsection{UML modellek hasonlósága}

Ohst, Welle és Kelter \cite{umlsimilarity} cikke konkrétan UML modellekkel foglalkozik. Kiemeli annak fontosságát, hogy ha két modellt összehasonlítunk, akkor az érdektelen adatokat figyelmen kívül kell hagyni, például az egyes modell elemek pozícióját (layout info). Foglalkozik a vizuális megjelenés problémájával, erre mutat pozitív és negatív példát is. Kiemeli, hogy lényeges különbség lehet modellek között, hogy van-e az elemeknek egyedi azonosítójuk (UUID), ennek hiányában a probléma perfekt megoldása sajnálatos módon NP-teljes. Hivatkozik a Rational Rose termékre, melyben egyfelõl van modell összehasonlítási / egyesítési funkcionalitás, másrészt viszont az egyesítés során elõkerül a modell konkrét XML-alapú szintaxisa, ennek ismerete nélkül aligha tudunk sikeres egyesítéseket véghezvinni.

Az eddigi cikkekbõl a következõ szempontok derültek ki az összehasonlító algoritmusokat illetõen:

\begin{itemize}
\item Történettel (history) foglalkozó / nem foglalkozó algoritmus
\item Egyedi azonosítást lehetõvé tevõ elem létezése / nem létezése
\item Az algoritmus metamodell-specifikus-e
\item A fejlesztõ grafikus felületet kap-e vagy a konkrét szintaxist is ismernie kell
\end{itemize}

\subsection{Gráfok hasonlóságainak típusai}

Gráfok hasonlóságának alapkérdéseivel foglalkozik Zager és Verghese prezentációja \cite{graphsimilarity}, melyben a hasonlóság következõ fajtáit határozzák meg:

\begin{itemize}
\item Izomorfia (csak igen/nem a válasz)
\item Szerkesztési távolság: hány lépés kell ahhoz, hogy az egyik gráfból eljussunk a másikba.
\item Maximális / minimális mérete a részgráfoknak / szupergráfnak
\end{itemize}

\subsection{Gráfok párosítása}

Zager MSc dolgozata \cite{zagermsc} a következõ újdonságokkal szolgál:

\begin{itemize}
\item Úgy is neki lehet állni a problémának, hogy a gráfokat különféle módokon mátrixokként ábrázoljuk és ezeket hasonlítjuk össze.
\item A feljebb említett iteratív hasonlóság-keresõ módszerét itt részletesen kifejti.
\end{itemize}

\subsection{Szakterület-specifikus összehasonlítás}

Lin, Gray és Jouault cikke \cite{dsmdiff} azt hangsúlyozza, hogy fontos, hogy az algoritmus metamodelltõl független legyen, a cikkben ismertetett \emph{DSMDiff} tetszóleges domain-specifikus nyelven íródott modellpélányokat kíván összehasonlítani. Magáról a DSMDiff-rõl nagyon keveset sikerült kideríteni, pedig a cikk szerint ez nem csak egy terv, hanem implementálták is.

\subsection{Transzformációk tesztelése és verziókezelés}

Lin, Zhang és Gray cikke \cite{comparechal} problémafelvetési céllal íródott, nem tartalmaz konkrét megoldásokat. A 2004-es írásban felvetett problémák egy rész már megoldódott, mivel részben a CVS problémái voltak ezek, melyek közül számosat az SVN már ma is megold, például a projekt-szintû verziózást a fájl-szintû helyett.

A fenti probléma-leírások és megoldás-vázlatok alapján az is napirendre került,
hogy mely már létezõ projekteket lenne érdemes kipróbálni ebben a témakörben.

A két elsõ jelölt:

\begin{itemize}
\item EMF Compare \cite{emfcompare}
\item Groove \cite{groove}
\end{itemize}

A probléma sokadik megfogalmazása tehát: az egyesítõ algoritmus jó lenne, ha nem egyetlen metamodell fölött tudna mûködni, cserébe viszont ha semmit se tudunk a metamodellrõl akkor nem nagyon lehet jól egyesíteni. Erre megoldás lehet, ha a metamodell információi is az algoritmus inputját képezik a két modellpélány mellett. Egy másik megoldás lehet, ha a metamodell információi alapján tudunk kódot generálni, és így tetszõleges metamodell számára könnyen elkészíthetõ a mûködõ algoritmus-implementáció.

Ezen kívül még probléma, hogy az algoritmusnak nagy elemszámú modelleket is jól kell tudnia kezelnie, a jelenlegi megoldások nagy része néhány ezer elem felett már nem végez gyakorlatban megengedhetõ idõn belül.

\subsection{Változás-vezérelt összehasonlítás}

A tanszéken született cikk \cite{changedriven} tudását végül nem használtam fel a késõbbiekben a félév során, mivel nem változás-vezérelt algoritmust implementáltam.

\subsection{X-Diff}

Olyan gráfok összehasonlítását végzõ algoritmusokat kerestem, melyek fák (körmentes gráfok). A szakirodalom ilyen téren már kisebb mértékben gazdag, pedig számos metamodell-csoport (például az összes EMF által kezelt) szigorú tartalmazási hierarchia szerint épül fel, tehát faként reprezentálható.

Az egyik legérdekesebb Wang, DeWitt és Cai cikke \cite{xdiff}, melyben az
\emph{X-Diff} algoritmust vázolják. Az algoritmust alapötlete nagyon hasonlít a
késõbb tárgyalt \emph{FMES} algoritmushoz, viszont ehhez nem találtam
nyilvánosan elérhetõ mûködõ kódot.

\subsection{VIATRA2}

A következõ lépés a VIATRA2 rendszerrel való ismerkedés volt. Mivel egy hallgató már korábban foglalkozott modell összehasonlítási témával, így elõször az ö algoritmusát \cite{karer} próbáltam ki. Ez a keretrendszerrel való ismerkedéshez kiváló feladat volt, az algoritmus viszont az én inputomra lefagyott (\emph{NullPointerException}).

Ezt követõen a VIATRA Java API-jával ismerkedtem, ennek keretében elkészült egy egyszerû (hello world) model comparator\cite{viatrahello}, ami csak összehasonlítja az egyes entitások nevét, relációinak számát, és ez alapján tekinti egyezõnek az egyes entitásokat vagy sem.

\subsection{Odyssey-VCS}

Ezzel párhuzamosan megpróbáltam felvenni a kapcsolatot az \emph{Odyssey-VCS}\cite{odyssey} szerzõivel, melynek célja egy modellek kezelésére kitalált EMF-alapó verziókezelõ lenne. Sajnálatos módon a szoftver elsó blikkre (out of the box) nem mûködött, a forráskódot meg többszöri levélváltás után se sikerült végül megkapni, bár határozott elutasítást nem kaptam (kutatási célokra).

\subsection{EMF Compare}

Utána az EMF Compare-rel ismerkedtem. Az
org .eclipse .emf .compare .examples .standalone csomagban van egy parancssorból
használható (standalone) példa, ez volt az amit a konzin véletlenül kitöröltünk
fordítási hiba miatt (mondván, hogy az csak példa). Mivel ez egy jó belépési
pont, letöltöttem újra, megjavítottam a függõségeit (dependency) és így már
lefordult. Innen már látszik, hogy az EMF esetén az összehasonlítás két részbõl
áll: elõször van egy \emph{match} rész, ez találja meg a hasonló részeket -
\emph{MatchService.doMatch()}, 2 EObject-et tud összehasonlítani -, majd ezután
jön a diffelés, ami a különbözõ részeket találja meg -
\emph{DiffService.doDiff()} ami egy MatchModel-t var, amit a
\emph{MatchService} ad vissza -, végül az ez által adott DiffModel-en tud
lefutni a merge - \emph{MergeService.merge()}.

Tehát ami elõször számunkra érdekes lehet, az az, hogy a \emph{MatchService}
hogy mûködik. Nyilván ez is strategy patternnel van megoldva, az
\emph{IMatchEngine} interfász implementaciójával. Az EMF beépítetten egyetlen
implementációt ad, ez pedig a \emph{GenericMatchEngine}. Ez egy remek 2000
soros implementáció, a részletek megismerésére idõ hiányában nem vállalkoztam,
de egy rövid összefoglaló \cite{genericmatchengine} leírja, hogy milyen
metrikákat használ.

Hasonló módon a match modelbõl a diff egy IDiffEngine-t implementáló osztállyal
oldható meg, erre a kódban az implementáció a \emph{GenericDiffEngine}.
(Szinten komplexebb, 900 sor.) Végül az utolsó lépés interfésze az
\emph{IMerger}, ennek egy implementációja a \emph{DefaultMerger} (~350 sor).

Tesztesetek tekintetében statikus modelljeik nincsenek, viszont van egy
\emph{EcoreModelUtils .createModel()}, amit lehet paraméterezni, hogy milyen
tesztmodelleket generáljon. (Egy egyszerû könyvek-szerzõk modell n az n-hez
kardinalitású kapcsolattal, az egyes attribútumok értékei véletlenszerûek, de
az egyedi azonosítást biztonsító \emph{xmiid} attribútumok stimmelnek, így a
matchernek meg kell találnia az egyezõ elemeket a modellben.) Ezt teszteli a
TwoWayContentMatchTest. Ezen kívül van még másik 2 teszt:

\emph{TwoWayModelMatchTest}: az elõzõ tesztben használt modellel dolgozik ez
is, nézi, hogy alapesetben minden elemet össze tud párosítani, aztán módosít
egy szerzõt, és várja, hogy azt a szerzõt már ne tudja megtalálni (legyen hozzá
\emph{UnMatchElement}), mivel a kettõnek más a könyvlistája.
(\emph{TwoWayResourceMatchTest}: hasonló, de resourcematch-et használ.)

Tehát a 3 match típus:

\begin{itemize}
\item ContentMatch: komparálás tartalom alapján (testvérek és szülõk figyelmen kívül hagyása)
\item ModelMatch: normál komparálás (figyelembe veszi az elõbb figyelmen kívül hagyott relációkat)
\item ResourceMatch: ez EObject-ek helyett Resource-okra fut. A dokumentáció
alapján úgy tûnik, hogy a Resource gyakorlatilag egy perzisztens tároló,
lehetnek benne EObject-ek, tehát ez algoritmikusan nem nagyon különbözik a
fenti 2 match típustól.
\end{itemize}

Ha interaktív összehasonlítás a cél, akkor a hivatkozás-jegyzékben említett
\cite{eclipseforum} bejegyzés hasznos lehet.

\subsection{Groove}

A Groove mögött dolgozó gráf-összehasonlító algoritmus leírása\cite{groovegraph} újabb ötleteket adhat a saját összehasonlító tervezésénél. A szerzõ is megjegyzi, hogy gráfok izomorfiáját alapesetben nem lehet polinomidõben vizsgálni. McKay algoritmusát használja, mely a következõt adja: egy gráfon és egy páronként nem-izomorf gráfokat tartalmazó halmazon dolgozik, és azt keresi, hogy a halmazból bármelyik elem izomorf-e a gráffal. Ha nem, akkor értelemszerûen felveszi az elemet a halmazba. Az algoritmus közelítõ ötletek segítségével polinom-idejû. Az ötletek a következõk:

\begin{itemize}
\item A gráf redukálása (izomorfia szempontjából lényegtelen elemek eltávolítása) vizsgálat elõtt.
\item A gráfok lenyomatának (hash) számítása, így ha a lenyomat-függvény gyors, az izomorfia konstans idõben eldönthetõ.
\item A lenyomatot készítõ függvény a gráf színezését használja fel építõkõként.
\end{itemize}

\section{A kiválaszatott módszer: FMES}

\subsection{Diff XML}

A DiffXML nevû eszközt azért tartom kiválónak a labor szempontjából, mert kiterjedt teszteset-gyûjteménnyel rendelkezik XML modellekbõl. Egy rövid kiértékelés alapján az eszköz tudja is amit hirdet magáról: XML modelleket tud összehasonlítani és foltozni (patch), a metamodell figyelembevétele nélkül.

Másik nagy elõnye, hogy mivel fákon dolgozik, gyorsabb, mint azon algoritmusok
melyek tetszõleges gráfokkal képesek dolgozni. Figyelembe véve, hogy sok modell
esetén a metamodell elõírja a szigorú tartalmazási hierarchiát (pl. EMF), ez a
megkötés sok modellpéldány esetén nem jelent gondot.

Felhasználói szemszögbõl úgy mûködik, hogy 2 XML modellt kér bemenetként és kimenetként egy olyan XML modellt ad, mely operációk listáját tartalmazza, mellyel el lehet jutni az elsõ modellbõl a másodikba. Ezt az eszköz szerkesztési szövegnek (edit script) hívja. Így tehát egy tipikus 3-utas egyesítés (3-way merge) megoldható a következõ lépésekkel:

\begin{itemize}
\item A közös õs és \emph{A} között végzünk összehasonlítást, ebbõl lesz egy folt
\item A foltot alkalmazzuk \emph{B}-re, a kimenet lesz az egyesített eredmény
\end{itemize}

A probléma a következõ: ugyan jól formázott lesz az eredmény, de nem biztos,
hogy a sémának is megfelel (valid).

További gond, hogyha ütközés lenne (például x-et módositjuk egyszer A-ra, másszor
B-re), akkor azt nem veszi észre, mivel az operácio csak azt írja, hogy "töröld
ki az elemet, írj bele A-t". Így aztán attól függõen A v B lesz az eredmény,
hogy melyiket hasonlítjuk és melyiket foltozzuk.

Azt is megnéztem, hogy B-t hasonlítva és A-t foltozva a kapott egyesítési eredmény
azonos az elõbbi módon kapott egyesítési eredménnyel, ami bizakodásra ad okot
az háttérben munkálkodó algoritmust tekintve.

\subsection{FMES}

A DiffXML eszköz összehasonlító moduljában alapértelmezett esetben egy FMES
nevû algoritmus oldja meg a tényleges összehasonlítást.

A formátum, amit kimenetként használ a diffxml és bemenetként a patchxml le van
írva a szerzõ disszertációjában\cite{diffxml}, de csak egyszerûen olvasva is
meglehetõsen intuitív.  Ebbõl következik, hogy a patchxml nem különösebben
bonyolult, egyszerûen csak végrehajtja a mûveleteket a bemenetrõl. Az érdekes
rész a diffxml.

A FMES algoritmusnak a precíz leírása megtalálható hivatkozások
között\cite{fmes}. Az algoritmus alapötlete egy iteratív megoldás, mely az
alfejezet végén került illusztrálásra.  Definiált egy két csomópontot
összehasonlító függvény. A fa levelei közül megkeressük azokat, melyek
megegyeznek és azonos útvonalon elérhetõek. Ha ezzel megvagyunk, a maradék
levelek között keressünk olyan egyezõ csomópontokat melyek eltérõ útvonalon
érhetõek el, de megegyeznek.  Ezután tekintsük azt a gráfot, melyet a levelek
elhagyásával kapunk. Futtassuk erre iteratív módon újfent az algoritmust.

\begin{figure}[H]
\centering
\includegraphics[width=40mm,keepaspectratio]{fmes/fmes2.eps}
\caption{A fa leveleinek keresése}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=40mm,keepaspectratio]{fmes/fmes3.eps}
\caption{Párosítás egyezõ úton}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=40mm,keepaspectratio]{fmes/fmes4.eps}
\caption{Párosítás eltérõ úton}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=40mm,keepaspectratio]{fmes/fmes5.eps}
\caption{Második iteráció: levél-keresés}

\end{figure}
\begin{figure}[H]
\centering
\includegraphics[width=40mm,keepaspectratio]{fmes/fmes6.eps}
\caption{Második iteráció: párosítás egyezõ úton}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=40mm,keepaspectratio]{fmes/fmes7.eps}
\caption{Második iteráció: párosítás eltérõ úton}
\end{figure}

\section{Implementáció}

Ebben a fejezetben két VIATRA plugin implementációját ismertetem: Az xml
importert valamint az FMES összehasonlítót.

Az xml importer egy VIATRA importert valósít meg. Ez egy Eclipse plugin, mely
egyrészt az \emph{org.eclipse.viatra2.core2.modelimport} kiterjesztési pontot
(extension point) használja, másrészt Java szinten az
\emph{org.eclipse.viatra2.imports.NativeImporter} interfészt implementálja.

A modell összehasonlító felépítése a következõ: egy általános modell
összehasonlító Eclipse plugin használja az
\emph{org.eclipse.viatra2.gui.contributedAction} kiterjesztési pontot, mely
Java szinten az
\emph{org.eclipse.viatra2.frameworkgui.actions.AbstractFrameworkGUIAction}
osztályból öröklõdik, majd ez definiál egy saját
\emph{org.eclipse.viatra2.model.comparator.IModelComparator} interfészt, melyet
az egyes algoritmusoknak implementálnia kell. Ezt az interfészt valósítja meg
az általam implementált
\emph{org.eclipse.viatra2.model.comparator. algorithms.vmiklos. fmes.FmesModelComparator}
is.

\subsection{VIATRA XML importer}

Egyszerû importert készítettem a releváns dokumentáció\cite{importdoc} alapján.

A cél az volt, hogy a diffxml teszteseteit be lehessen húzni VIATRA-ba és ne
kelljen kézzel felvenni az entitásokat, ezzel el is készültem.

Egyszerû alatt azt kell érteni, hogy csak az \emph{entity} meg \emph{text}
típusú csomópontokat figyeli és az alapján IEntity-ket hoz létre a tartalmazási
hierarchiát figyelembe véve, ellenben az attribútumokkal már nem foglalkozik.

Ez a munka az SVN-ben szintén elérhetõ\cite{xmlimportsvn}.

\subsection{FMES illesztése VIATRA-hoz}

Az FMES VIATRA-hoz illesztése (portolása) során az elsõ lépés a a párosítás
implementálása volt. A párosítás és a két modell alapján a következõ lépés a
szerkesztési szöveg elõállítása lesz. Ebbõl elõször a beillesztõ és a
törlést biztosító részt készítettem el.

Egy egyszerû modellre a kimenet a következõ:

\begin{verbatim}
origin.a matches working.a
origin.a.b matches working.a.b
origin.a.x unmatched
origin.a.z matches working.a.z
origin.a.b.y matches working.a.b.y

working.a matches origin.a
working.a.X unmatched
working.a.b matches origin.a.b
working.a.z matches origin.a.z
working.a.b.y matches origin.a.b.y

Applying: <insert name="X" parent="a"/>
Applying: <delete node="a.x"/>
\end{verbatim}

Az implementáció\cite{fmes4viatra} ezen állapotában a két legfontosabb
hiányosság, hogy nincsenek kezelve az áthelyezések, valamint a relációkat nem
veszi figyelembe a két csúcsot összehasonlító függvény.

Tekintsük át tehát, hogyan oldható meg az áthelyezések detektálása, és ennek mi
az alapötlete:

\begin{itemize}
\item Ha van egy ModelElement ami már párosított (tehát van megfelelõje a másik modellben), de
\item A szülõje nem párosított (tehát törlésre fog kerülni), akkor
\item Tegyük át a ModelElementet a \emph{szülõ(párja(elem))} alá.
\end{itemize}

Ezen kívül teszteseteket készítettem három tesztesetet:

\begin{itemize}

\item Egyszerû esetet ahol csak beillesztés ill. törlés van
\item Áthelyezés-detektálást igénylõ esetet
\item Kombináltat
\end{itemize}

Kimenet a kombinált esetre:

\begin{verbatim}
test1a.a matches test2a.a
test1a.a.b matches test2a.a.b
test1a.a.d matches test2a.a.d
test1a.a.e matches test2a.a.e
test1a.a.f unmatched
test1a.a.b.1 unmatched
test1a.a.b.4 matches test2a.a.b.4
test1a.a.b.c matches test2a.a.b.c
test1a.a.b.c.3 matches test2a.a.b.c.3
test1a.a.d.5 matches test2a.a.d.5
test1a.a.e.6 matches test2a.a.e.6
test1a.a.f.7 matches test2a.a.g.7

test2a.a matches test1a.a
test2a.a.9 unmatched
test2a.a.b matches test1a.a.b
test2a.a.d matches test1a.a.d
test2a.a.e matches test1a.a.e
test2a.a.g unmatched
test2a.a.b.4 matches test1a.a.b.4
test2a.a.b.c matches test1a.a.b.c
test2a.a.b.c.3 matches test1a.a.b.c.3
test2a.a.d.5 matches test1a.a.d.5
test2a.a.e.6 matches test1a.a.e.6
test2a.a.g.7 matches test1a.a.f.7

Applying: <insert name="9" parent="a"/>
Applying: <insert name="g" parent="a"/>
Applying: <move name="a.f.7" parent="a.g"/>
Applying: <delete name="a.f"/>
Applying: <delete name="a.b.1"/>
\end{verbatim}

\subsection{Dokumentáció}

Az FMES kód kapcsán felmerült, hogy ezt vagy azt miért úgy csináltam, és a
válasz az volt, hogy azért, hogy a diffxml-es fmes kódtól minimálisan térjen
csak el a VIATRA felett futó kód. Ennek leginkább akkor volt jelentõsége, mikor még az áthelyezések detektálása nem mûködött. Ez az állapot ottvan SVN-ben (r1360), viszont most kitisztítottam, ami egész pontosan a következõket jelenti:

\begin{itemize}
\item Az összes osztály és metódus megjegyzésekkel (javadoc) van ellátva.
\item Az olyan metódusok vagy kódrészek melyek "esetleg a jövõben hasznosak
lehetnek, de jelenleg nem használtak", törlésre kerültek.
\item Az xmlimporter kód esetén nem voltak hosszú használatlan kódrészek, de a dokumentáció hiányzott, ezt elkészítettem hozzá.
\end{itemize}

Ezen kívül elkészítettem a labor végén esedékes prezentáció fóliáit.

\section{Tesztelés}

A tesztelés módja a következõ: Az XML modelleket rá kell húzni a modelltérre
(ehhez szükséges a korábban leírt XML importer) és a fájlnévbõl a kiterjesztés
elhagyásával képzett névvel ellátott, legfelsõ szintû elem alá kerül
létrehozásra a modell VIATRA-s reprezentációja. Ha ezt legalább két modellre
megtettük, akkor futtatható a modell összehasonlító úgy, hogy a modelltéren
jobb gombbal kattintunk, majd kiválasztjuk a \emph{Contributions} majd
\emph{Run model comparator} menüpontokat. Az ekkor megjelenõ ablakban pontosan
két modellt kell kiválasztani, majd az OK gombra kattintva indítható az
összehasonlítás.

A korábban leírt egyszerû teszt bemeneteken kívül egyéb tesztelést nem
végeztem, összetettebb méréseket végezni véleményem szerint majd akkor lenne
érdemes ha funkcionalitás szempontjából az algoritmus már teljes: amíg a
metamodell kezelése nem készül el, valamint a relációkat nem vesszük figyelembe
elvérható mértékben addig úgy gondolom nincs értelme részletes diagramokat
készíteni arról, hogy pontosan mennyi idõt igényel adott modelleknek az
összehasonlítása. A fejlesztés során használt kis bemenetekre a futási idõ
elhanyagolható (kevesebb, mint 1 másodperc) volt.

A félév során a tesztelés és dokumentáció készítés céljára használt környezet a
következõ volt:

E dokumentáció alapjául a félév során vezetett wiki oldalak\cite{wikireadme}
\cite{wikilog} szolgáltak. A dokumentáció tördelése a a tanszék által küldött
fedlap alapján a \TeX{} 3.141592 verziójával készült, Frugalware Linux
operációs rendszeren. A munkához az Eclipse 3.5-ös (Galileo) verzióját
használtam, míg a VIATRA rendszert SVN-bõl, a r1353-at. Erre (és nem egy stabil
kiadás használatára) azért volt szükség, mert a félév elején még nem volt
elérhetõ a VIATRA 3.1-es kiadása, az elõzõ kiadás pedig már kifejezetten õsinek
számított, a konzulens se javasolta a használatát.

A VIATRA rendszer fejlesztését Eclipse-bõl futtatott Eclipse-ben teszteltem (runtime Eclipse), mely a következõ alap VIATRA projekteket tartalmazta:

\begin{itemize}
\item org.eclipse.viatra2.core2
\item org.eclipse.viatra2.editor
\item org.eclipse.viatra2.editor.text
\item org.eclipse.viatra2.gtasm.interpreter
\item org.eclipse.viatra2.gtasm.interpreter.impl
\item org.eclipse.viatra2.gtasm.interpreter.term
\item org.eclipse.viatra2.gtasm.model
\item org.eclipse.viatra2.gtasm.patternmatcher
\item org.eclipse.viatra2.gtasm.patternmatcher.impl
\item org.eclipse.viatra2.gtasm.patternmatcher.incremental
\item org.eclipse.viatra2.gtasm.patternmatcher.incremental.rete
\item org.eclipse.viatra2.gtasm.trigger
\item org.eclipse.viatra2.gtasm.typing.model
\item org.eclipse.viatra2.gui
\item org.eclipse.viatra2.help
\item org.eclipse.viatra2.imports.uml2.galileo
\item org.eclipse.viatra2.imports.vtml
\item org.eclipse.viatra2.loaders.vtcl\_lpgparser
\end{itemize}

Valamint természetesen a már korábban említett org.eclipse.viatra2.imports.vmiklos.xml és org.eclipse.viatra2.model.comparator.

\section{Jövõbeli lehetõségek}

Számos lehetõséget kellett figyelmen kívül hagyni idõ hiányában ezek közül a legfontosabbak:

\begin{itemize}
\item XML importer: Séma megkövetelése, így a VIATRA-beli entitásokhoz típusok lennének rendelhetõek.
\item Csak az összehasonlító került megvalósításra, ennek kimenete alapján egy modell egyesítõ eszközt is lehetne készíteni.
\item A két entitást összehasonlító elem finomítható lenne.
\item Az FMES fákon dolgozik, egyéb gráf-összehasonlító algoritmusok is elérhetõek (pl. Groove-ból).
\end{itemize}

\begin{thebibliography}{4}
\addcontentsline{toc}{section}{Hivatkozások}

%\bibitem{Programming Erlang} Joe Armstrong: Programming Erlang, http://www.p.com/jaerlang/programming
\bibitem{VIATRA} VIATRA2 (VIsual Automated model TRAnsformations), http://wiki.eclipse.org/VIATRA2
\bibitem{ericsson} Lars Bendix, Pär Emanuelsson: Requirements for Practical Model Merge - An Industrial Perspective
\bibitem{zager} LA Zager, GC Verghese: Graph similarity scoring and matching
\bibitem{umlsimilarity} D Ohst, M Welle, U Kelter: Differences between versions of UML diagrams
\bibitem{graphsimilarity} Laura Zager, George Verghese: Graph similarity
\bibitem{zagermsc} Laura Zager: Graph Similarity and Matching
\bibitem{dsmdiff} Y Lin, J Gray, F Jouault: DSMDiff - a differentiation tool for domain-specific models
\bibitem{comparechal} Y Lin, J Zhang, J Gray: Model Comparison - A Key Challenge for Transformation Testing and Version Control in Model Driven Software Development
\bibitem{emfcompare} Eclipse Modeling Framework Compare, http://wiki.eclipse.org/index.php/EMF\_Compare
\bibitem{groove} GRaphs for Object-Oriented VErification, http://sourceforge.net/projects/groove/
\bibitem{xdiff} Yuan Wang, David J. DeWitt, Jin-Yi Cai: X-Diff - An Effective Change Detection Algorithm for XML Documents
\bibitem{karer} VIATRA2 Model Comparator by Name, https://svn.inf.mit.bme.hu/ viatra/viatra\_extra/ R3/mit.bme.hu/ trunk/org.eclipse.viatra2.model.comparator/ src/org/ eclipse/viatra2/ model/comparator/ algorithms/karer/
\bibitem{odyssey} Hamilton Oliveira, Leonardo Murta, Cláudia Werner: Odyssey-VCS - a Flexible Version Control System for UML Model Elements
\bibitem{viatrahello} Saját kód: VIATRA egyszerû modell összehasonlító, https://svn.inf.mit.bme.hu/ viatra/viatra\_extra/ R3/mit.bme.hu/ trunk/org.eclipse.viatra2.model.comparator/ src/org/ eclipse/viatra2/ model/comparator/ algorithms/vmiklos/hello/
\bibitem{changedriven} Gábor Bergmann, István Ráth, Gergely Varró, Dániel Varró: Change-Driven Model Transformations: Taxonomy and Language
\bibitem{genericmatchengine} EMF FAQ: GenericMatchEngine leírás, http://wiki.eclipse.org/ EMF\_Compare\_FAQ \#What\_kind \_of\_.22 strategies.22 \_use\_EMF \_compare\_.3F
\bibitem{eclipseforum} EMF Compare: How to use EMF Compare in Java, http://www.eclipse.org/ forums/ index.php ?t=msg\&th=37716 \&goto=122763\#msg\_122763
\bibitem{diffxml} Adrian Mouat: Tools for comparing and patching XML files, http://prdownloads .sourceforge.net/ diffxml/dissertation.ps ?download
\bibitem{fmes} Sudarshan S. Chawathe, Anand Rajaraman, Hector Garcia-Molina, Jennifer Widom: Change Detection in Hierarchically Structured Information
\bibitem{fmes4viatra} Saját kód: FMES VIATRA rendszerre, https://svn.inf.mit.bme.hu/ viatra/viatra\_extra/ R3/mit.bme.hu/ trunk/org.eclipse.viatra2.model.comparator/ src/org/ eclipse/viatra2/ model/comparator/ algorithms/vmiklos/fmes/
\bibitem{groovegraph} Arend Rensink: Isomorphism Checking for Symmetry Reduction
\bibitem{importdoc} Model import and export: Creating model importers, http://wiki.eclipse.org/ VIATRA2/UseCases/ModelExportImport \#Creating\_model\_importers
\bibitem{xmlimportsvn} Saját kód: Egyszerû XML importer, https://svn .inf.mit.bme.hu/ viatra/viatra\_extra/ R3/mit.bme.hu/ trunk/org.eclipse.viatra2 .imports.vmiklos.xml/
\bibitem{wikireadme} A labor során vezetett heti összefoglalókat tartalmazó wiki oldal, https:// trac .inf.mit .bme.hu/ eclipse/wiki/ vmiklos\_readme
\bibitem{wikilog} A labor során vezetett részletesebb naplót tartalmazó wiki oldal, https:// trac .inf.mit .bme.hu/ eclipse/wiki/ vmiklos\_log

\end{thebibliography}
\end{document}
